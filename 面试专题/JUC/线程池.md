### 线程池原理？

#### 使用场景

假设一个服务器完成一项任务所需时间为：T1-创建线程时间，T2-在线程中执行任务的时间，T3-销毁线程时间。`如果T1+T3远大于T2，则可以使用线程池，以提高服务器性能。`

#### 组成

1. 线程池管理器（ThreadPool）：用于创建并管理线程池，包括创建线程池，销毁线程池，添加新任务；
2. 工作线程（PoolWorker）：线程池中线程，在没有任务时处于等待状态，可以循环的执行任务；
3. 任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行，它主要规定了任务的入口，任务执行后的收尾工作，任务的执行状态等。
4. 任务队列（taskQueue）：用于存放没有处理的任务。提供一种缓存机制。

#### 原理

线程池技术正是关注如何缩短或调整T1，T3时间的技术，从而提高服务器性能程序的。它把T1，T3分别安排在服务器程序的启动和结束的时间段，这样在服务器处理客户请求时，不会有T1，T3的开销了。

#### 工作流程

1. 线程池刚创建时，里面没有一个线程（也可以设置参数prestartAllCoreThreads启动预期数量主线程）。任务队列是作为参数传进来的。不过就算队列里面有任务，线程池也不会马上执行他们。
2. 当调动excute()方法添加一个任务时，线程池会做如下判断：
   1. 如果正在运行的线程数量小于corePoolSize，那么马上创建线程运行这个任务；
   2. 如果正在运行的线程数量大于或等于corePoolSize，那么将这个任务放入队列；
   3. 如果这时候队列满了，而且正在运行的线程数量小于maximumPoolSize，那么还是要创建非核心线程立刻运行这个任务；
   4. 如果队列满了，而且正在运行的线程数量大于或等于maximumPoolSize，那么线程池会抛出异常RejectExecutionException。
3. 当一个线程完成任务时，它会从队列中获取下一个任务来执行。
4. 当一个线程无事可做，超过一定时间（KeepAliveTime）时，线程池会判断，如果当前运行的线程数大于corePoolSize，那么这个线程就会被停掉。如果线程池的所有任务完成后，它最终会收缩到corePoolSize的大小。